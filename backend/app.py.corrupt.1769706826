# backend/app.py
from fastapi import FastAPI, HTTPException, BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import FileResponse, HTMLResponse, JSONResponse
import subprocess
import json
import os
import shlex
import re
import logging
import time
import threading
from pathlib import Path
import mutagen
import humanize
from queue import Queue, Empty
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

app = FastAPI(title="Beets Replacement API")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

# ---------------------------------------------------------------------------
# CONFIG / PATHS
# ---------------------------------------------------------------------------

ALBUMS_FILE = "/data/albums.json"
RECENT_FILE = "/data/recent_albums.json"
REGEN_SCRIPT = "/app/scripts/regenerate_albums.py"
BEETS_CONFIG = "/config/config.yaml"
INDEX_HTML = "/app/static/index.html"

INBOX_PATH = Path("/music/inbox")
LIBRARY_PATH = Path("/music/library")

# Tunables
DEBOUNCE_INBOX = 20.0
DEBOUNCE_LIBRARY = 10.0
IMPORT_TIMEOUT = 3600
REGEN_TIMEOUT = 900

logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(message)s")
logger = logging.getLogger("beets-replacement")

# ---------------------------------------------------------------------------
# UTILITIES
# ---------------------------------------------------------------------------

def run_cmd(cmd, timeout=300):
    try:
        out = subprocess.check_output(cmd, shell=True, stderr=subprocess.STDOUT, timeout=timeout)
        return True, out.decode(errors="replace")
    except subprocess.CalledProcessError as e:
        return False, e.output.decode(errors="replace")
    except Exception as e:
        return False, str(e)

def _run_cmd_list(cmd_list, timeout=300):
    try:
        p = subprocess.run(cmd_list, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, timeout=timeout)
        return p.returncode == 0, p.stdout or ""
    except Exception as e:
        return False, str(e)

# ---------------------------------------------------------------------------
# STATIC FILE ROUTES
# ---------------------------------------------------------------------------

@app.get("/music/library/{full_path:path}", include_in_schema=False)
@app.head("/music/library/{full_path:path}", include_in_schema=False)
def serve_library_file(full_path: str):
    fs_path = os.path.join("/music/library", full_path)
    if os.path.exists(fs_path) and os.path.isfile(fs_path):
        return FileResponse(fs_path)
    raise HTTPException(status_code=404, detail="Not found")

@app.get("/placeholder.jpg", include_in_schema=False)
@app.head("/placeholder.jpg", include_in_schema=False)
def serve_placeholder():
    p = "/app/static/placeholder.jpg"
    if os.path.exists(p) and os.path.isfile(p):
        return FileResponse(p, media_type="image/jpeg")
    raise HTTPException(status_code=404, detail="Not found")

# ---------------------------------------------------------------------------
# UI + JSON
# ---------------------------------------------------------------------------

@app.get("/", response_class=HTMLResponse)
def serve_index():
    if os.path.exists(INDEX_HTML):
        return FileResponse(INDEX_HTML, media_type="text/html")
    return HTMLResponse("<h1>Index not found</h1>", status_code=404)

@app.get("/data/albums.json")
def serve_albums_json():
    if os.path.exists(ALBUMS_FILE):
        return FileResponse(ALBUMS_FILE, media_type="application/json")
    return JSONResponse({"detail": "Not Found"}, status_code=404)

# ---------------------------------------------------------------------------
# API ENDPOINTS
# ---------------------------------------------------------------------------

@app.get("/api/stats")
def stats():
    ok, out = run_cmd(f"beet -c {shlex.quote(BEETS_CONFIG)} stats")
    if ok:
        return {"beets_stats": out}
    try:
        with open(ALBUMS_FILE, "r", encoding="utf-8") as f:
            data = json.load(f)
        return {"albums": len(data)}
    except Exception as e:
        return {"albums": 0, "error": str(e)}

@app.post("/api/library/refresh")
def refresh_library():
    if not os.path.exists(REGEN_SCRIPT):
        raise HTTPException(status_code=500, detail="regenerate script missing")
    ok, out = run_cmd(f"python3 {shlex.quote(REGEN_SCRIPT)}", timeout=120)
    if not ok:
        raise HTTPException(status_code=500, detail=out)
    return {"status": "ok", "detail": out.strip()}

@app.post("/api/library/import")
def import_library(background_tasks: BackgroundTasks):
    cmd = f"beet -c {shlex.quote(BEETS_CONFIG)} import -A /music/inbox"
    try:
        def _run():
            subprocess.run(cmd, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        background_tasks.add_task(_run)
        return {"status": "started", "cmd": cmd}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/albums")
def albums(limit: int = 5000):
    try:
        with open(ALBUMS_FILE, "r", encoding="utf-8") as f:
            data = json.load(f)
        return data[:limit]
    except Exception:
        return []

@app.get("/api/albums/recent")
def recent(limit: int = 12):
    try:
        with open(RECENT_FILE, "r", encoding="utf-8") as f:
            data = json.load(f)
        return data[:limit]
    except Exception:
        return []

# ---------------------------------------------------------------------------
# INBOX API ENDPOINTS
# ---------------------------------------------------------------------------

@app.get("/api/inbox/stats")
def inbox_stats():
    tracks = 0
    total_seconds = 0
    total_bytes = 0
    artists = set()
    albums = set()
    albumartists = set()

    if not INBOX_PATH.exists():
        return {
            "tracks": 0,
            "total_time": "0 seconds",
            "total_size": "0 B",
            "artists": 0,
            "albums": 0,
            "albumartists": 0,
        }

    for file in INBOX_PATH.rglob("*"):
        if not file.is_file():
            continue
        if file.suffix.lower() not in [".mp3", ".flac", ".m4a", ".ogg"]:
            continue

        try:
            audio = mutagen.File(file)
            if not audio or not getattr(audio, "info", None):
                continue
            tracks += 1
            total_seconds += int(audio.info.length)
            total_bytes += file.stat().st_size

            tags = audio.tags or {}
            def _get_tag(t):
                v = tags.get(t)
                if not v:
                    return None
                if isinstance(v, (list, tuple)):
                    return str(v[0])
                return str(v)

            tag_artist = _get_tag("artist")
            tag_album = _get_tag("album")
            tag_albumartist = _get_tag("albumartist")

            if tag_artist:
                artists.add(tag_artist)
            if tag_album:
                albums.add(tag_album)
            if tag_albumartist:
                albumartists.add(tag_albumartist)

        except Exception:
            continue

    return {
        "tracks": tracks,
        "total_time": humanize.precisedelta(total_seconds),
        "total_size": humanize.naturalsize(total_bytes),
        "artists": len(artists),
        "albums": len(albums),
        "albumartists": len(albumartists),
    }

@app.get("/api/inbox/tree")
def inbox_tree():
    if not INBOX_PATH.exists():
        return {"folders": {}}
    tree = {}
    for artist_dir in INBOX_PATH.iterdir():
        if not artist_dir.is_dir():
            continue
        tree[artist_dir.name] = [d.name for d in artist_dir.iterdir() if d.is_dir()]
    return {"folders": tree}

@app.get("/api/inbox/folder")
def inbox_folder(artist: str, album: str):
    folder = INBOX_PATH / artist / album
    if not folder.exists():
        return {"files": []}
    files = [f.name for f in folder.iterdir() if f.is_file()]
    return {"files": files}

# ---------------------------------------------------------------------------
# WATCHERS / WORKERS
# ---------------------------------------------------------------------------

_inbox_q = Queue()
_lib_q = Queue()
_inbox_last = {}
_lib_last = {}
_inbox_lock = threading.Lock()
_lib_lock = threading.Lock()
_stop_event = threading.Event()

class InboxHandler(FileSystemEventHandler):
    def on_any_event(self, event):
        try:
            src = event.src_path
            target = src if os.path.isdir(src) else os.path.dirname(src)
            target = os.path.normpath(target)
            base = os.path.basename(target)
            if not target or base.startswith(".") or base.startswith("~"):
                return
            now = time.time()
            with _inbox_lock:
                last = _inbox_last.get(target, 0)
                if now - last < DEBOUNCE_INBOX:
                    return
                _inbox_last[target] = now
                if target in list(_inbox_q.queue):
                    logger.debug("Inbox already queued: %s", target)
                    return
            logger.info("Inbox enqueue: %s", target)
            _inbox_q.put(target)
        except Exception:
            logger.exception("Inbox handler error")

class LibraryHandler(FileSystemEventHandler):
    def on_any_event(self, event):
        try:
            src = event.src_path
            target = src if os.path.isdir(src) else os.path.dirname(src)
            target = os.path.normpath(target)
            if not str(target).startswith(str(LIBRARY_PATH)):
                return
            base = os.path.basename(target)
            if base.startswith(".") or base.startswith("~"):
                return
            now = time.time()
            with _lib_lock:
                last = _lib_last.get(target, 0)
                if now - last < DEBOUNCE_LIBRARY:
                    return
                _lib_last[target] = now
                if target in list(_lib_q.queue):
                    logger.debug("Library already queued: %s", target)
                    return
            logger.info("Library enqueue: %s", target)
            _lib_q.put(target)
        except Exception:
            logger.exception("Library handler error")

def inbox_worker(beets_config_path: str):
    logger.info("Inbox worker started")
    while not _stop_event.is_set():
        try:
            target = _inbox_q.get(timeout=1)
        except Empty:
            continue
        try:
            time.sleep(DEBOUNCE_INBOX)
            if not os.path.exists(target):
                logger.info("Inbox target disappeared: %s", target)
                _inbox_q.task_done()
                continue
            args = ["beet", "-c", beets_config_path, "import", "-A", target]
            logger.info("Running import: %s", " ".join(shlex.quote(a) for a in args))
            res = subprocess.run(args, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, timeout=IMPORT_TIMEOUT, text=True)
            out = res.stdout or ""
            if res.returncode == 0:
                logger.info("Import succeeded for %s", target)
            else:
                logger.error("Import failed for %s rc=%s out=%s", target, res.returncode, (out[:400] if out else ""))
        except Exception:
            logger.exception("Exception during inbox import for %s", target)
        finally:
            _inbox_q.task_done()
    logger.info("Inbox worker stopping")

def library_worker():
    logger.info("Library worker started")
    while not _stop_event.is_set():
        try:
            target = _lib_q.get(timeout=1)
        except Empty:
            continue
        try:
            time.sleep(DEBOUNCE_LIBRARY)
            if not os.path.exists(target):
                logger.info("Library target missing: %s", target)
                _lib_q.task_done()
                continue

            success = False
            tried = []

            if os.path.exists(REGEN_SCRIPT):
                # 1) exact path
                cmd1 = ["python3", REGEN_SCRIPT, target]
                tried.append(("exact", cmd1))
                ok, out = _run_cmd_list(cmd1, timeout=REGEN_TIMEOUT)
                if ok:
                    success = True
                else:
                    # 2) strip trailing bracketed suffix like " [241]" using a single-line regex
                    t2 = re.sub(r'\s*

\[\d+\]

\s*$', '', target)
                    if t2 != target and os.path.exists(t2):
                        cmd2 = ["python3", REGEN_SCRIPT, t2]
                        tried.append(("strip_brackets", cmd2))
                        ok, out = _run_cmd_list(cmd2, timeout=REGEN_TIMEOUT)
                        if ok:
                            success = True

                # 3) fallback: full regen
                if not success:
                    cmd3 = ["python3", REGEN_SCRIPT]
                    tried.append(("full", cmd3))
                    ok, out = _run_cmd_list(cmd3, timeout=REGEN_TIMEOUT * 2)
                    if ok:
                        success = True

                if success:
                    logger.info("Regen succeeded for %s", target)
                else:
                    logger.error("Regen failed for %s after tries: %s", target, [t[0] for t in tried])
            else:
                logger.warning("REGEN_SCRIPT missing; no action for %s", target)

        except Exception:
            logger.exception("Exception during library regen for %s", target)
        finally:
            _lib_q.task_done()
    logger.info("Library worker stopping")

@app.on_event("startup")
def start_watchers():
    global _inbox_observer, _lib_observer, _inbox_worker, _lib_worker
    if INBOX_PATH.exists():
        _inbox_observer = Observer()
        _inbox_observer.schedule(InboxHandler(), str(INBOX_PATH), recursive=True)
        _inbox_observer.start()
        _inbox_worker = threading.Thread(target=inbox_worker, args=(BEETS_CONFIG,), daemon=True)
        _inbox_worker.start()
        logger.info("Started inbox watcher on %s", INBOX_PATH)
    else:
        logger.warning("Inbox path missing: %s", INBOX_PATH)

    if LIBRARY_PATH.exists():
        _lib_observer = Observer()
        _lib_observer.schedule(LibraryHandler(), str(LIBRARY_PATH), recursive=True)
        _lib_observer.start()
        _lib_worker = threading.Thread(target=library_worker, daemon=True)
        _lib_worker.start()
        logger.info("Started library watcher on %s", LIBRARY_PATH)
    else:
        logger.warning("Library path missing: %s", LIBRARY_PATH)

@app.on_event("shutdown")
def stop_watchers():
    logger.info("Stopping watchers")
    _stop_event.set()
    try:
        if '_inbox_observer' in globals() and _inbox_observer:
            _inbox_observer.stop(); _inbox_observer.join(timeout=5)
        if '_lib_observer' in globals() and _lib_observer:
            _lib_observer.stop(); _lib_observer.join(timeout=5)
    except Exception:
        logger.exception("Error stopping observers")
    logger.info("Watchers stopped")
